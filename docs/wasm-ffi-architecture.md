# WASM FFI Architecture

## The Right Way: Zero-Copy Shared Memory

### Memory Layout

```
┌─────────────────────────────────────────────┐
│ Rust ECS Memory (Component Columns)         │
│ ┌─────────────────────────────────────┐     │
│ │ Position[]: [x0,y0,x1,y1,x2,y2...]  │     │
│ │ Velocity[]: [vx0,vy0,vx1,vy1,...]   │     │
│ └─────────────────────────────────────┘     │
└─────────────────────────────────────────────┘
         ↓ Map into WASM linear memory
┌─────────────────────────────────────────────┐
│ WASM Linear Memory (SharedArrayBuffer)      │
│ ┌─────────────────────────────────────┐     │
│ │ Same bytes, no copy!                │     │
│ │ TypeScript sees Int32Array view     │     │
│ └─────────────────────────────────────┘     │
└─────────────────────────────────────────────┘
```

### Developer Experience

```typescript
// Developer writes clean TypeScript
class MovementSystem {
  update(positions: Vec2[], velocities: Vec2[], dt: number) {
    for (let i = 0; i < positions.length; i++) {
      positions[i].x += velocities[i].x * dt;
      positions[i].y += velocities[i].y * dt;
    }
  }
}
```

### What the Engine Does

1. **Compile-time:**
   - TypeScript → AssemblyScript compiler → WASM
   - Generate glue code for component access
   - Bake in helper functions (Vec2 accessors, etc.)

2. **Runtime:**
   - Allocate component memory in Rust
   - Create SharedArrayBuffer backed by that memory
   - Instantiate WASM with the shared buffer
   - Call WASM functions, passing buffer offsets

### Implementation

```rust
// Rust side
pub struct WasmRuntime {
    instance: wasmi::Instance,
    memory: SharedMemory, // Maps to Rust component slices
}

impl WasmRuntime {
    pub fn call_system(&mut self, world: &mut World) {
        // Get component columns
        let pos_slice = world.column_mut::<Position>(archetype);
        let vel_slice = world.column::<Velocity>(archetype);
        
        // Map into WASM memory (zero-copy!)
        self.memory.map_slice(0, pos_slice);
        self.memory.map_slice(1, vel_slice);
        
        // Call WASM: updateSystem(pos_offset, vel_offset, count, dt)
        self.instance.call("updateSystem", &[
            0u32.into(),           // positions at offset 0
            1u32.into(),           // velocities at offset 1  
            count.into(),
            dt.into(),
        ]);
        
        // No copy back needed - WASM modified Rust memory directly!
    }
}
```

```typescript
// Generated by engine (injected into WASM module)
class Vec2 {
  constructor(private buffer: Float32Array, private index: number) {}
  
  get x(): number { return this.buffer[this.index * 2 + 0]; }
  set x(v: number) { this.buffer[this.index * 2 + 0] = v; }
  
  get y(): number { return this.buffer[this.index * 2 + 1]; }
  set y(v: number) { this.buffer[this.index * 2 + 1] = v; }
}

// WASM export (generated from developer's TypeScript)
export function updateSystem(
  posOffset: u32,
  velOffset: u32, 
  count: u32,
  dt: f32
): void {
  const positions = new Float32Array(memory.buffer, posOffset, count * 2);
  const velocities = new Float32Array(memory.buffer, velOffset, count * 2);
  
  for (let i = 0; i < count; i++) {
    positions[i*2 + 0] += velocities[i*2 + 0] * dt; // x
    positions[i*2 + 1] += velocities[i*2 + 1] * dt; // y
  }
}
```

## Why This Works

1. **WASM linear memory** is just a big ArrayBuffer
2. **Rust can map slices** into that ArrayBuffer as views
3. **WASM sees the same bytes** via Float32Array/Int32Array
4. **No serialization, no copying** - true zero-copy

## QuickJS vs WASM

| Feature | QuickJS | WASM |
|---------|---------|------|
| Shared memory | ❌ No | ✅ Yes (SharedArrayBuffer) |
| Zero-copy | ❌ No | ✅ Yes |
| Hot reload | ✅ Instant | ⚠️ Requires recompile |
| Debug | ✅ Easy | ⚠️ Harder |
| Performance | ⚠️ Good | ✅ Excellent |
| Use case | **Dev builds** | **Ship builds** |

## The Plan

### Phase 1: QuickJS (Current)
- Rapid prototyping
- Per-entity or small-batch calls
- Accept the copy overhead
- Great DX, fast iteration

### Phase 2: WASM (Ship)
- AssemblyScript compiles same TypeScript
- SharedArrayBuffer for zero-copy
- 10-100x faster for large entity counts
- Same API, different runtime

### Phase 3: Custom Compiler (Future)
- TypeScript → SSA IR → WASM + Rust
- Inline hot systems into Rust
- Best of both worlds

## Next PoC

**PoC 4: AssemblyScript → WASM with SharedArrayBuffer**
- Compile TypeScript to WASM
- Map Rust component slices into WASM memory
- Call WASM functions with offsets
- Verify zero-copy access
- Benchmark vs QuickJS
