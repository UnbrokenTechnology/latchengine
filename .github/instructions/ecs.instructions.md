```instructions
---
applyTo: "crates/latch_core/src/**"
---

# Latch ECS — Implementation Design (Revised)

## Overview
A fast, deterministic, cache-aware ECS designed for large-scale simulations, scripting integration, and efficient memory usage.  
Core principles:
- Fixed-layout archetypes (no per-entity heap).
- Columnar, page-based storage with power-of-two page sizes.
- Double-buffered component columns for deterministic parallelism.
- Single-writer-per-component rule.
- Dynamic component model supporting scripting languages.
- Batch despawning + swap-remove compaction.
- Generic PagedPool usable outside ECS.
- 50 Hz fixed tick, deterministic simulation.

**Why 50 Hz?**
- 1000 ms is divisible by 50, making time calculations simpler. This helps us synchronize with real-world time so we can keep servers in sync and avoid drift.
- 50 Hz is fast enough for smooth gameplay while allowing more time for complex simulations and scripting.
- 50 Hz is a common choice for server tick rates in multiplayer games, so it aligns well with our networking model.
- 50 Hz allows for a larger rollback window (8 ticks = 160 ms) which provides better latency compensation for players.

Note that physics simulation tick rate can be decoupled from frame rate. The ECS will run at 50 Hz, but rendering can be at 60 FPS or higher with interpolation. All rendering interpolation should be done on the GPU to avoid CPU overhead.

---

## Entities
### Purpose
Lightweight identifiers for rows in archetype storage.

### Properties
- **Globally unique** `EntityId` (u64 recommended).
- No per-entity heap or object allocation.
- Data lives in **Column** storage; entity only maps to `{archetype, global_idx}`.

### Storage Structures
- **World-level index**:  
  `HashMap<EntityId, EntityLoc { archetype_id, global_idx }>`
- **Archetype sidecar Column** (`entity_ids`):  
  maps `row → EntityId` inside an archetype.

### Spawning
- Constructed via **EntityBuilder**.
- World resolves archetype, allocates a new row in each Column, writes components + EntityId.

### Despawning
- Two APIs:
  - **Fast path** (from systems): use row/global index directly → push to per-archetype queue.
  - **General path**: `world.despawn(entity_id)` → lookup via global index → enqueue.
- All despawns batched and applied at end-of-tick.

---

## Components
### Purpose
Small, hot, frequently accessed data; SoA column storage.

### Dual model: Rust-native & Scripted
#### Rust Components
- Use `define_component!(Type)` macro.
- Name inferred via `std::any::type_name::<T>()` (path trimmed).
- Fields inferred via `memoffset::offset_of!` (macro helper).
- Produces a **ComponentHandle** with:
  - `id`, `name`
  - `size`, `align`, `stride` (padded to align)
  - field metadata array

#### Script/External Components
- Registered via:
  - `register_external_component_with_fields(name, size, align, stride, &[FieldMeta])`
- Field metadata includes:
  - `name`, `offset`, `type_info`, `count`

### Field Access
- Systems bind field names → offsets **once** at registration.
- Runtime access via:
  - Rust: direct struct access in typed systems.
  - Scripted: `component.read(field_name)` / `write`.

### Heavy or Static Data
- **Not** stored in components.
- Use separate **asset/resource system**.
- Components store lightweight handles:
  - e.g. `Renderable { mesh: MeshHandle, material: MaterialHandle }`.

---

## Systems
### Purpose
Transform ECS data in deterministic parallel batches.

### Binding
- When registering:
  - Rust systems infer **read vs write** from parameter types (`&T`/`&mut T`).
  - Script systems explicitly provide `reads[]` and `writes[]`.
- Scheduler checks:
  - **Single writer per component per tick** (strong rule for determinism & performance).
  - Fail on conflicts.

### Execution
- Systems operate on tiles generated by the runner.
- Provided slice views:  
  `read_slice: &[T]`, `write_slice: &mut [T]`
- No shared mutable data across tiles.

---

## Double Buffering
### Purpose
Deterministic updates under parallelism.

### Structure
- Each Column has two PagedPools:
  - `cur` (read)
  - `nxt` (write)
- Systems always read from `cur`, write to `nxt`.
- At end of tick:
  - `swap(cur, nxt)` for all columns in all archetypes.

---

## ArchetypeStore
### Purpose
Storage for all entities of the same component set.

### Contents
- One **Column** per component type.
- An `entity_ids` sidecar column (single-buffer).
- Batch despawn buffer.

### Page Size Selection
- Compute `bytes_per_row = sum(size_of(component)) + size_of(EntityId)`.
- Choose L2 budget (e.g., 64–256 KiB).
- `ROWS_PER_PAGE = floor(L2_budget / bytes_per_row)` → round down to nearest power-of-two.
- Ensures pages fit comfortably in L2.

### Tiling
- Tiling is done **per archetype**, using:
  - L1 size
  - `bytes_per_entity` for the system
  - `rows_per_page`
- Uses global helper (see below).

### Despawn Application
- Merge thread-local queues.
- Group by page.
- Convert `EntityId` → row via index if needed.
- Call:
  - `Column.free_bulk_swap_remove(global_idxs)`
- Fix global index for moved entities.

---

## Column<T>
### Purpose
Store one component type for an archetype.

### Structure
- `cur: PagedPool<T>`
- `nxt: PagedPool<T>`
- Element size and alignment from component metadata.
- Implements lockstep alloc/free.

### Public API
- `len_total()`
- `alloc_one() -> gidx`
- `alloc_bulk(n)`
- `slice_read(range) -> &[T]`
- `slice_rw(range) -> (&[T], &mut [T])`
- `swap_buffers()`
- `free_one_swap_remove(gidx)`
- `free_bulk_swap_remove(gidxs)`

### Quirks
- Never expose overlapping mutable slices.
- All alloc/free must apply to both buffers.

---

## PagedPool<T>
### Purpose
Generic paged object pool with stable intra-page addresses and O(1) swap-remove.

### Structure
- `rows_per_page` must be **power-of-two**.
- Page index computed via:
  - `page = gidx >> k`
  - `slot = gidx & (rows_per_page - 1)`

### Public API
- `len_total()`
- `alloc_one() -> gidx`
- `alloc_bulk(n) -> Vec<Range<usize>>`
- `write_at(gidx, T)`
- `slice_tile(range) -> Result<&[T], PoolError>`
- `slice_tile_mut(range) -> Result<&mut [T], PoolError>`
- `clamp_to_page(start, nominal_len, total_len)`
- `free_one_swap_remove(gidx)`
- `free_bulk_swap_remove(Vec<usize>)`

### Notes
- Ranges must not cross page boundaries; checked in API.
- Generic enough to be used by audio engine, networking, etc.
- No reallocation; pages never move.

---

## Page<T>
### Purpose
Fixed-size allocation chunk used by PagedPool.

### Structure
- Backing buffer: `Box<[MaybeUninit<T>]>`
- `len`: number of initialized items
- Capacity: number of rows per page (fixed)

### API
- `alloc_one() -> idx`
- `alloc_bulk(n) -> Range<usize>`
- `write_at(idx, T)`
- `slice(range) -> &[T]`
- `slice_mut(range) -> &mut [T]`
- `free_one(idx) -> Option<(from, to)>`
- `free_bulk(indices, fix_index_local)`

### Notes
- Uses `assume_init_read` / `assume_init_drop`.
- Swap-removal keeps pages dense.
- No panics in release: return `Result` where appropriate.

---

## Tile Length Computation
### Purpose
Ensure each tile’s working set fits in L1 cache.

### Helper Function (Generic)
```rust
fn compute_tile_len(
    bytes_per_entity: usize,
    l1_bytes: usize,
    rows_per_page: usize,
    alpha: f32,
) -> usize
```

Rules:
- `budget = alpha * L1`
- `tile_len = budget / bytes_per_entity`
- Clamp to `[1, rows_per_page]`
- Align to cache line multiples (64B)

Used by ECS, audio, networking, etc.

---

## Parallel Execution Model
- Each tile is processed by exactly one thread.
- Slices are page-local: no cross-page tiles.
- Tiles for all required components are zipped together in the runner.
- Double-buffering ensures no read-write conflicts.
- Single-writer-per-component rule ensures no write-write conflicts.

---

## Despawning & Determinism
- Systems push despawn requests to **per-thread** queues.
- At end-of-tick:
  - Merge queues (sorted for determinism).
  - Convert to global indices.
  - Bulk free with swap-remove per Column.
  - Fix indices for moved entities.
- After maintenance, `swap_buffers()` for all Columns.

---

## Save/Load (Future)
- Persist:
  - Archetype identifiers
  - EntityId
  - Component name → field names → raw bytes
- On load:
  - Look up components in registry.
  - Validate fields & offsets.
  - Reconstruct archetypes and rows.
- Perfect forward compatibility requires migration layer (future work).

---

## Rust Implementation Notes
- `Box<[MaybeUninit<T>]>` for stable in-page memory.
- Use `unsafe` only in:
  - pointer writes (`ptr::write`)
  - slice creation (`from_raw_parts`)
  - manual drops (`assume_init_drop`)
- Ensure no aliasing mutable references across tiles.
- Use `debug_assert!` inside hot loops; API methods return `Result`.
- Use `OnceCell` to lazily register Rust components.
- Derive read/write sets automatically from Rust function signatures.
